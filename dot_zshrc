# If you come from bash you might have to change your $PATH.
# PATH is configured below using modern zsh array syntax

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
# ZSH_THEME="agnoster"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
zstyle ':omz:update' frequency 1

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
HIST_STAMPS="yyyy-mm-dd"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.

# Handy helper to cut down on repetitive command -v checks.
command_exists() { command -v "$1" >/dev/null 2>&1; }

# Plugin dependency checking and loading
check_plugin_deps() {
  local missing_plugins=()

  # Check for optional dependencies
  if ! command_exists git; then
    echo "Warning: git plugin loaded but git command not found" >&2
  fi

  if ! command_exists zoxide; then
    echo "Warning: zoxide plugin loaded but zoxide command not found" >&2
    echo "Install with: curl -sS https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | bash" >&2
  fi

  if ! command_exists fzf; then
    echo "Warning: fzf-tab plugin loaded but fzf command not found" >&2
    echo "Install fzf for optimal experience" >&2
  fi

  # Check for plugin files in Oh My Zsh
  local plugin_dir="${ZSH}/plugins"
  local custom_plugin_dir="${ZSH_CUSTOM:-$ZSH/custom}/plugins"

  for plugin in fast-syntax-highlighting zsh-autosuggestions zsh-history-substring-search; do
    if [[ ! -d "$plugin_dir/$plugin" && ! -d "$custom_plugin_dir/$plugin" ]]; then
      missing_plugins+=("$plugin")
    fi
  done

  if (( ${#missing_plugins[@]} > 0 )); then
    echo "Warning: Missing Oh My Zsh plugins: ${missing_plugins[*]}" >&2
    echo "Install with: git clone https://github.com/zsh-users/PLUGIN_NAME \${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/PLUGIN_NAME" >&2
  fi
}

plugins=(git zoxide fzf-tab fast-syntax-highlighting zsh-autosuggestions zsh-history-substring-search)

# Check plugin dependencies
check_plugin_deps

# Configure the Pure prompt when installed via Homebrew, dnf, or apt.
setup_pure_prompt() {
  local pure_dirs=()
  local pure_found=false

  if [[ -d "$HOME/.zsh/pure" ]]; then
    pure_dirs+=("$HOME/.zsh/pure")
  fi

  if command_exists brew; then
    local brew_prefix
    if brew_prefix="$(brew --prefix 2>/dev/null)"; then
      pure_dirs+=("$brew_prefix/share/zsh/site-functions")
    fi
  fi

  if command_exists dnf; then
    pure_dirs+=("/usr/share/zsh/site-functions")
  fi

  if command_exists apt; then
    pure_dirs+=("/usr/share/zsh/vendor-functions" "/usr/share/zsh/site-functions")
  fi

  local dir
  for dir in "${pure_dirs[@]}"; do
    if [[ -d "$dir" ]]; then
      if (( ! ${fpath[(Ie)$dir]} )); then
        fpath+=("$dir")
      fi
      if [[ -f "$dir/prompt_pure_setup" ]]; then
        pure_found=true
      fi
    fi
  done

  autoload -U promptinit && promptinit

  if prompt pure >/dev/null 2>&1; then
    return
  fi

  prompt default >/dev/null 2>&1 || true

  if [[ "$pure_found" != true ]]; then
    echo "Warning: Pure prompt not available. Install with brew install pure, sudo dnf install zsh-pure-prompt, or sudo apt install zsh-pure-prompt." >&2
  else
    echo "Warning: Failed to load Pure prompt; falling back to default prompt." >&2
  fi
}

# Zsh autosuggestion tweaks for smoother UX.
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
ZSH_AUTOSUGGEST_USE_ASYNC=1
ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=60
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'   # subtle grey

source $ZSH/oh-my-zsh.sh

setup_pure_prompt

# --------------------------------------------------
# History substring search (↑ / ↓)
# --------------------------------------------------
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='bg=blue,fg=white,bold'
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND='bg=red,fg=white'

# Initialize zoxide after Oh My Zsh for proper integration
if command_exists zoxide; then
  eval "$(zoxide init zsh)"
fi

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
if command_exists nvim; then
  export EDITOR='nvim'
  export VISUAL='nvim'
elif command_exists vim; then
  export EDITOR='vim'
  export VISUAL='vim'
elif command_exists vi; then
  export EDITOR='vi'
  export VISUAL='vi'
else
  export EDITOR='nano'
  export VISUAL='nano'
fi

# Use different editor for SSH sessions if needed
if [[ -n $SSH_CONNECTION ]] && command_exists vim; then
  export EDITOR='vim'
  export VISUAL='vim'
fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# Lazy loading for NVM to improve startup performance
export NVM_DIR="$HOME/.nvm"
__nvm_lazy_load() {
  # Avoid re-sourcing once nvm is loaded successfully
  case "${__nvm_lazy_loaded-}" in
    1) return 0 ;;
    missing) return 1 ;;
  esac

  if [ -s "$NVM_DIR/nvm.sh" ]; then
    unset -f nvm 2>/dev/null || true
    unset -f nvm_find_nvmrc 2>/dev/null || true
    \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    __nvm_lazy_loaded=1
    return 0
  fi

  if [ -z "${__nvm_lazy_warned-}" ]; then
    echo "nvm_lazy_load: missing $NVM_DIR/nvm.sh" >&2
    __nvm_lazy_warned=1
  fi
  __nvm_lazy_loaded=missing
  return 1
}

nvm() {
  __nvm_lazy_load || return $?
  nvm "$@"
}

nvm_find_nvmrc() {
  __nvm_lazy_load || return $?
  nvm_find_nvmrc "$@"
}

# Auto-load nvm on cd if .nvmrc exists
autoload -U add-zsh-hook
load-nvmrc() {
  if [ ! -s "$NVM_DIR/nvm.sh" ]; then
    return
  fi

  local nvmrc_path="$(nvm_find_nvmrc)"
  if [ -n "$nvmrc_path" ]; then
    local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")
    if [ "$nvmrc_node_version" = "N/A" ]; then
      nvm install
    elif [ "$nvmrc_node_version" != "$(nvm version)" ]; then
      nvm use
    fi
  elif [ -n "$(PWD=$OLDPWD nvm_find_nvmrc)" ] && [ "$(nvm version)" != "$(nvm version default)" ]; then
    echo "Reverting to nvm default version"
    nvm use default
  fi
}
add-zsh-hook chpwd load-nvmrc

# XDG Base Directory Specification support
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"

# Path hygiene: ensure personal bins appear early.
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  ${path[@]:-}
)
typeset -U path PATH
export PATH

export ZELLIJ_AUTO_ATTACH=true
# export ZELLIJ_AUTO_EXIT=true
# eval "$(zellij setup --generate-auto-start zsh)"

# =========================================================
#  Modern, Robust, and Performant Zsh Configuration
# ---------------------------------------------------------
#  * Uses fzf, fd, ripgrep (rg), bat, eza, pure prompt
#  * Fine‑tuned history, keybindings, aliases, and helpers
#  * Extensive comments for future maintenance
# =========================================================

# ------------------------------------------------------------------
# 1️⃣  Basic Zsh Options & History (Performance Optimized)
# ------------------------------------------------------------------
# Directory navigation
setopt autocd                  # `cd dir` → `cd dir`
setopt autopushd               # Make cd push old directory onto stack
setopt pushdminus              # `cd -` behaves like in bash
setopt pushdtohome             # `cd` with no args goes to $HOME
setopt pushdsilent             # Don't print directory stack
setopt pushdignoredups         # Don't push duplicates

# Command correction and completion
setopt correct                 # Auto‑correct mistyped commands
setopt correctall              # Correct all arguments in line

# History optimization
setopt histignoredups          # Do not store duplicate history lines
setopt histignorespace         # Don't record commands starting with space
setopt sharehistory            # Share history live between all shells
setopt histreduceblanks        # Trim extra spaces in history entries
setopt extendedhistory         # Store timestamps & command duration
setopt histverify              # Show expanded history before executing
setopt histexpiredupsfirst     # Remove oldest duplicates first
setopt histfindnodups          # Don't show duplicates in search

# Globbing and pattern matching
setopt extendedglob            # Adds vi‑style globbing
setopt globdots                # Include dotfiles in glob patterns
setopt nomatch                 # Pass through unmatched patterns
setopt numericglobsort         # Sort numeric filenames numerically

# Job control
setopt notify                  # Report job status immediately
setopt longlistjobs            # List jobs in long format
setopt nohup                   # Don't send HUP to running jobs on shell exit

# History file configuration (XDG compliant)
HISTFILE="${XDG_STATE_HOME}/zsh/history"
[[ -d "${HISTFILE%/*}" ]] || mkdir -p "${HISTFILE%/*}"
HISTSIZE=50000
SAVEHIST=50000

unsetopt beep


# ------------------------------------------------------------------
# Enhanced Completion Configuration
# ------------------------------------------------------------------
# Use modern completion system
autoload -Uz compinit
[[ -d "${XDG_CACHE_HOME}/zsh" ]] || mkdir -p "${XDG_CACHE_HOME}/zsh"
# Check if we need to regenerate completion cache (once per day)
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit -d "${XDG_CACHE_HOME}/zsh/zcompdump-${ZSH_VERSION}"
else
  compinit -C -d "${XDG_CACHE_HOME}/zsh/zcompdump-${ZSH_VERSION}"
fi

# Enhanced completion styling
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format '%F{yellow}-- %d --%f'
zstyle ':completion:*:messages' format '%F{purple}-- %d --%f'
zstyle ':completion:*:warnings' format '%F{red}-- No matches found --%f'
zstyle ':completion:*:corrections' format '%F{green}-- %d (errors: %e) --%f'

# Use LS_COLORS for file completion
if [[ -n ${LS_COLORS:-} ]]; then
  zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
fi

# Performance optimizations
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path "${XDG_CACHE_HOME}/zsh/completion-cache"
zstyle ':completion:*' accept-exact '*(N)'
zstyle ':completion:*' squeeze-slashes true

# Enhanced process completion
zstyle ':completion:*:*:*:*:processes' command 'ps -u $USER -o pid,user,comm -w'
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;34=0=01'

# SSH/SCP/RSYNC completion from known hosts
zstyle ':completion:*:(ssh|scp|rsync):*' tag-order 'hosts:-host:host hosts:-domain:domain hosts:-ipaddr:ip\ address *'
zstyle ':completion:*:(scp|rsync):*' group-order users files all-files hosts-domain hosts-host hosts-ipaddr

# fzf-tab tweaks
zstyle ':fzf-tab:*' switch-group ',' '.'  # , and . to move between groups
zstyle ':fzf-tab:*' fzf-bindings 'ctrl-y:preview-page-up' 'ctrl-e:preview-page-down'
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath 2>/dev/null || ls -1 $realpath'


# ------------------------------------------------------------------
# 3️⃣  Aliases – Modern replacements & safety aliases
# ------------------------------------------------------------------
# Keep the original grep handy (if you need classic behaviour)
alias grep_orig='grep'
if command_exists rg; then
  alias grep='rg --smart-case'
fi
if command_exists bat; then
  alias cat='bat --paging=never --style=plain'
elif command_exists batcat; then
  alias bat='batcat'
  alias cat='bat --paging=never --style=plain'
fi
if command_exists eza; then
  alias ls='eza --classify=auto --color=auto'
fi
alias ..='cd ..'
alias ...='cd ../..'
if command_exists nvim; then
  alias v='nvim'
fi
if command_exists rg; then
  alias psg='ps aux | rg'
else
  alias psg='ps aux | grep'
fi
if ! command_exists fd && command_exists fdfind; then
  alias fd='fdfind'
fi
alias please='sudo $(fc -ln -1)'
alias reload!='exec zsh'


# ------------------------------------------------------------------
# 4️⃣  fzf, fd, bat, eza – Default settings & keybindings
# ------------------------------------------------------------------

# Set up fzf key bindings and fuzzy completion with error handling
if command_exists fzf; then
  fzf_setup_success=false

  if command_exists brew; then
    if brew_prefix="$(brew --prefix 2>/dev/null)"; then
      fzf_keybindings="$brew_prefix/opt/fzf/shell/key-bindings.zsh"
      fzf_completion="$brew_prefix/opt/fzf/shell/completion.zsh"
      if [[ -f "$fzf_keybindings" && -f "$fzf_completion" ]]; then
        source "$fzf_keybindings" && source "$fzf_completion" && fzf_setup_success=true
      fi
    fi
  fi

  if [[ "$fzf_setup_success" = false ]]; then
    # Try system-wide installation
    if [[ -f /usr/share/doc/fzf/examples/key-bindings.zsh && -f /usr/share/doc/fzf/examples/completion.zsh ]]; then
      source /usr/share/doc/fzf/examples/key-bindings.zsh && source /usr/share/doc/fzf/examples/completion.zsh && fzf_setup_success=true
    fi
  fi

  if [[ "$fzf_setup_success" = false ]]; then
    # Fallback to fzf's built-in setup
    if eval "$(fzf --zsh 2>/dev/null)"; then
      fzf_setup_success=true
    fi
  fi

  [[ "$fzf_setup_success" = false ]] && echo "Warning: fzf setup failed" >&2
  unset fzf_setup_success fzf_keybindings fzf_completion
fi

# Guard against missing tools – silently skip configuration if not found
if command_exists fd; then
  export FZF_DEFAULT_COMMAND='fd --type file --hidden --follow --exclude .git'
  export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
fi

export FZF_DEFAULT_OPTS=$(cat <<'FZF_OPTS'
--height=50% --layout=reverse --border
--preview-window=up,40%,wrap
--bind=ctrl-y:preview-page-up,ctrl-e:preview-page-down
--preview='if [[ -d {} ]]; then
             if command_exists eza; then
               eza --long --git --ignore-glob=.git --no-user --no-time {} | head -40
             else
               ls -la {}
             fi
           else
             if command_exists bat; then
               bat --style=numbers --color=always {}
             else
               cat {}
             fi
           fi'
FZF_OPTS
)
# --------------------------------------------------
# Update helper covering macOS & Linux package managers
# --------------------------------------------------
ksu() {
  if command_exists brew; then
    printf 'Using Homebrew...\n'
    brew update && brew upgrade && brew cleanup
  elif command_exists dnf; then
    printf 'Using dnf...\n'
    sudo dnf update -y && sudo dnf upgrade -y && sudo dnf clean all
  elif command_exists apt; then
    printf 'Using apt...\n'
    sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y && sudo apt clean
  else
    printf 'No supported package manager (brew/dnf/apt) found.\n'
    return 1
  fi

  if command_exists npm; then
    npm install -g npm@latest
    npm outdated -g || true
    npm update -g
  fi

  if command_exists uv; then
    uv tool upgrade --all
    uv python upgrade
    uv cache clean
    uv cache prune
  fi

  if command_exists flatpak; then
    flatpak update -y
    flatpak uninstall --delete-data --unused
  fi

  if command_exists snap; then
    sudo snap refresh
  fi
}
alias ksu='ksu'

# ------------------------------------------------------------------
# 7️⃣  Environment Variables & PATH
# ------------------------------------------------------------------
export PAGER='less'
export LESS='-R'
if [[ -t 1 ]]; then
  export GPG_TTY=$(tty)
fi

# Optional: start ssh-agent if not already running with error handling.
if command_exists pgrep && command_exists ssh-agent; then
  if ! pgrep -u "$USER" ssh-agent >/dev/null 2>&1; then
    if ssh_agent_output="$(ssh-agent -s 2>/dev/null)"; then
      eval "$ssh_agent_output" >/dev/null 2>&1
    else
      echo "Warning: Failed to start ssh-agent" >&2
    fi
    unset ssh_agent_output
  fi
fi

# Load additional environment overrides if present.
if [[ -s "$HOME/.local/bin/env" ]]; then
  . "$HOME/.local/bin/env"
fi

# EOF

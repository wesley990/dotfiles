# If you come from bash you might have to change your $PATH.
export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
# ZSH_THEME="agnoster"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
zstyle ':omz:update' frequency 1

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
HIST_STAMPS="yyyy-mm-dd"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# =========================================================
#  Modern, Robust, and Performant Zsh Configuration
# ---------------------------------------------------------
#  * Uses fzf, fd, ripgrep (rg), bat, eza, pure prompt
#  * Fine‑tuned history, keybindings, aliases, and helpers
#  * Extensive comments for future maintenance
# =========================================================

# ------------------------------------------------------------------
# 1️⃣  Basic Zsh Options & History
# ------------------------------------------------------------------
setopt autocd                  # `cd dir` → `cd dir`
setopt correct                 # Auto‑correct mistyped commands
setopt histignoredups          # Do not store duplicate history lines
setopt sharehistory            # Share history live between all shells
setopt pushdminus              # `cd -` behaves like in bash
setopt pushdtohome             # `cd` with no args goes to $HOME
setopt histreduceblanks        # Trim extra spaces in history entries
setopt extendedhistory         # Store timestamps & command duration
setopt extendedglob            # Adds vi‑style globbing
setopt nomatch                 # Turns off the “no glob match error”
setopt notify                  # Enables asynchronous‑job notifications

# History file configuration
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

unsetopt beep


# ------------------------------------------------------------------
# 2️⃣  Prompt – Pure (fallback to default if missing)
# ------------------------------------------------------------------
# Pure is a fast, minimal prompt that shows git status, virtualenvs, etc.
# If you do not have it installed, we fall back to the standard prompt.
autoload -Uz promptinit
promptinit
prompt pure || prompt default



# ------------------------------------------------------------------
# 3️⃣  Aliases – Modern replacements & safety aliases
# ------------------------------------------------------------------
# Keep the original grep handy (if you need classic behaviour)
alias grep_orig='grep'              # classic grep
alias grep='rg --smart-case'        # default to ripgrep
alias cat='bat --paging=never --style=plain'  # colourized `cat`
alias ls='eza --color=auto -F'     # modern ls (eza) with colour & classification
alias ..='cd ..'
alias ...='cd ../..'

# Helper: grep for processes (uses ripgrep under the hood)
alias psg='ps aux | rg'             # use `rg` after aliasing grep



# ------------------------------------------------------------------
# 4️⃣  fzf, fd, bat, eza – Default settings & keybindings
# ------------------------------------------------------------------
# Guard against missing tools – silently skip configuration if not found
if command -v fd >/dev/null 2>&1; then
  # Default command that fzf runs when you hit Ctrl‑T
  export FZF_DEFAULT_COMMAND="fd --type file --hidden --follow --exclude .git"
fi

# Preview is now unconditional: show bat output for files, short `eza` for dirs
export FZF_DEFAULT_OPTS="
  --height 50% --layout reverse --border
  --preview-window 'up:40%:wrap'
  --preview '
    if [[ -d {} ]]; then
      eza --long --git --ignore-glob=.git --no-user --no-time {} | head -40
    else
      bat --style=numbers --color=always {}
    fi
  '
"

# Source fzf keybindings if the script exists
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# ==============================================================================
# § GIT POWER-USER CONFIGURATION FOR ZSH
# ==============================================================================
# This configuration provides a comprehensive set of aliases, functions, and
# an interactive tab-completion system to streamline your Git workflow.
#
# Sections:
# 1. Core Git Configuration
# 2. Daily Workflow Aliases & Functions
# 3. Git Worktree Management
# 4. Dynamic Tab Completion Script
#
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# § 1. CORE GIT CONFIGURATION
# ------------------------------------------------------------------------------
# Set the default editor for Git commit messages, rebasing, etc.
# Using a powerful editor like Neovim or VS Code is highly recommended.
export GIT_EDITOR=nvim

# ------------------------------------------------------------------------------
# § 2. DAILY WORKFLOW ALIASES & FUNCTIONS
# ------------------------------------------------------------------------------
# These aliases and functions are organized by common Git tasks.

# --- Status ---
# Description: Check the state of your repository.
alias gst='git status'
function gss() { git status -s; } # Short, staged status (e.g., ' M file.txt')
function gup() { git remote update && git status; } # Update remotes and then show status

# --- Logging & History ---
# Description: View project history.
alias glog='git log --oneline --graph --decorate --all' # Your original concise log
alias gloga="git log --graph --pretty=format:'%C(auto)%h -%d %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'" # A more detailed, colorful log
function gsf() { git show -s --format=fuller "$@"; } # Show full author/commit info for a commit

# --- Staging & Committing ---
# Description: Add and save your changes.
alias gaa='git add --all'
alias gcm='git commit -m' # Commit staged files with a message
function gca() { git commit -a -m "$@"; } # Add all tracked files and commit
alias gundo='git reset HEAD~1 --mixed' # Undo last commit, keeping changes in your working directory

# --- Branching ---
# Description: Manage your branches.
alias gb='git branch'
alias gbl='git branch -a' # List all local and remote branches
alias gch='git checkout -b' # Create a new branch and switch to it
#alias gco='git checkout'
function gk() { git checkout -; } # Switch back to the previously checked-out branch
alias gbd='git branch -d' # Delete a merged local branch
function gbf() { git branch -D "$@"; } # Force-delete a local branch

# --- Stashing ---
# Description: Temporarily save uncommitted changes.
function gs() { git stash push -m "$@"; } # Stash changes with a descriptive message
alias gsp='git stash pop' # Apply the most recent stash and remove it from the stash list
alias gsl='git stash list' # List all stashes

# --- Remotes & Syncing ---
# Description: Interact with remote repositories.
alias gpl='git pull'
alias gpr='git pull --rebase' # Pull and rebase to avoid merge commits
alias gp='git push'
alias gpb='git push -u origin HEAD' # Push current branch and set it to track the remote branch
alias gpushf='git push --force-with-lease' # Safer force-push; won't overwrite upstream changes
alias gbal='git fetch --all --prune && git pull' # Fetch all, prune deleted branches, and pull

# --- Advanced Functions ---
# Description: Powerful one-liners for complex tasks.
function gcl() { git clone --recursive "$@"; } # Clone a repo, including its submodules

# Usage: glr 3
# Rebase the last `n` commits (default n=1)
function glr() {
  local n=${1:-1}
  git rebase -i HEAD~"$n"
}

# Usage: grb
#        grb develop
# Description: Rebase the current branch onto the repo's default branch (main/master) or a specified branch.
function grb() {
  local default_branch=${1:-}
  if [[ -z $default_branch ]]; then
    # Try origin/HEAD first
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null \
                     | sed 's|^refs/remotes/origin/||')
    # Fallback to main or master
    if [[ -z $default_branch ]]; then
      default_branch=main
      if ! git rev-parse --verify "$default_branch" >/dev/null 2>&1; then
        default_branch=master
      fi
    fi
  fi
  git rebase "$default_branch"
}

# Usage: gsq
# Description: Squashes the last commit into the one before it without changing the commit message.
# Perfect for cleaning up "fixup" commits before pushing.
alias gsq='git reset --soft HEAD~1 && git commit --amend --no-edit'

# ------------------------------------------------------------------------------
# § 3. GIT WORKTREE MANAGEMENT
# ------------------------------------------------------------------------------
# Description: Commands for managing multiple working trees attached to a single repository.
# This allows you to work on different branches simultaneously without stashing.

alias gwtl='git worktree list' # List all worktrees for this repository
alias gwtp='git worktree prune' # Clean up stale worktree metadata

# Usage: gwtc <branch-name> [path]
# Description: Creates a new worktree.
# - If only a branch is given, it creates a directory named after the branch
#   in the parent folder (e.g., ../<branch-name>).
# - If a path is specified, it uses that path.
function gwtc() {
  if [[ -z "$1" ]]; then
    echo "Usage: gwtc <branch> [path]" >&2
    return 1
  fi
  local branch="$1"
  local path="${2:-$branch}"
  local repo_root
  repo_root=$(git rev-parse --show-toplevel)

  # If the supplied path is relative, make it absolute relative to the repo root
  if [[ "${path:0:1}" != "/" ]]; then
    path="$repo_root/$path"
  fi

  echo "Creating worktree for branch '$branch' at '$path'..."
  git worktree add "$path" "$branch"
}

# Usage: gwtr
#        gwtr <branch-or-path>
# Description: Removes a worktree.
# - If run with no arguments from within a worktree, it removes itself.
# - Otherwise, it removes the worktree specified by its branch name or path.
function gwtr() {
  if [[ -z "$1" ]]; then
    local current=$(git rev-parse --show-toplevel)
    local main=$(git rev-parse --show-toplevel --show-superproject-root 2>/dev/null)
    # If we’re in the main repo or the main super‑project, refuse
    if [[ "$current" == "$main" ]]; then
      echo "Error: This is the main worktree and cannot be removed." >&2
      return 1
    fi
    echo "Removing current worktree at '$current'..."
    git worktree remove "$current"
  else
    echo "Removing worktree '$1'..."
    git worktree remove "$1"
  fi
}

# ------------------------------------------------------------------------------
# § 4. DYNAMIC TAB COMPLETION SCRIPT
# ------------------------------------------------------------------------------
# This script creates a 'gha' command that acts as a dispatcher for all other
# git aliases and provides a helpful, descriptive tab-completion menu.

# Step 1: Define the descriptions for all your 'gha' aliases.
# This is the single source of truth for the completion menu.
# The key is the part of the alias *after* 'gha' (e.g., for 'ghaco', the key is 'co').
typeset -A _gha_aliases
_gha_aliases=(
  # Status
  st    "status"
  ss    "status -s (short, staged status)"
  up    "remote update && git status"
  # Logging
  log   "log --oneline --graph --decorate --all"
  loga  "log (detailed, colorful graph)"
  sf    "show -s --format=fuller (full commit info)"
  # Committing
  aa    "add --all"
  cm    "commit -m (commit staged files)"
  ca    "commit -a -m (add all tracked and commit)"
  undo  "reset HEAD~1 --mixed (undo last commit)"
  # Branching
  b     "branch"
  bl    "branch -a (all local and remote)"
  ch    "checkout -b (create and switch branch)"
  co    "checkout"
  k     "checkout - (previous branch)"
  bd    "branch -d (delete merged branch)"
  bf    "branch -D (force delete branch)"
  # Stashing
  s     "stash push -m (stash with a message)"
  sp    "stash pop"
  sl    "stash list"
  # Syncing
  pl    "pull"
  pr    "pull --rebase"
  p     "push"
  pb    "push -u origin HEAD (set upstream)"
  pushf "push --force-with-lease (safer force push)"
  bal   "fetch --all --prune && git pull"
  # Advanced
  cl    "clone --recursive"
  lr    "rebase -i HEAD~<n> (interactive rebase)"
  rb    "rebase <default-branch> (rebase onto main/master)"
  sq    "reset --soft HEAD~1 && commit --amend"
  # Worktree
  wtl   "worktree list"
  wtc   "worktree create <branch> [path]"
  wtr   "worktree remove [path]"
  wtp   "worktree prune"
)

# Step 2: Create the 'gha' dispatcher function.
# This allows you to type `gha co my-branch` which it will execute as `ghaco my-branch`.
# It also acts as a transparent wrapper, so `gha diff` works just like `git diff`.

function gha() {
  # No args → show status (quick overview)
  if [[ $# -eq 0 ]]; then
    git status --short --branch
    return
  else
    git "$@"
  fi

  local sub="${1}"          # e.g. "co" from `gha co foo`
  shift

  local target="gha$sub"

  # Resolve the name that zsh will actually run:
  # * If it’s an alias, use `eval` so the alias expands.
  # * If it’s a function, just call it.
  # * Otherwise forward everything to git directly.
  local type
  type=$(type -t "$target" 2>/dev/null)

  if [[ $type == "function" ]]; then
    "$target" "$@"
  elif [[ $type == "alias" ]]; then
    eval "$target" "$@"
  else
    git "$sub" "$@"
  fi
}
 

# Step 3: Define the completion function for our 'gha' command.
# This function reads the _gha_aliases array and formats it for Zsh's completion system.
_gha_completions() {
  local -a words
  for key value in ${(kv)_gha_aliases}; do
    words+=("$key:$value")
  done
  _describe 'gha commands' words
}

# Step 4: Tie the completion function to the 'gha' command.
autoload -Uz compinit && compinit
#compdef _g_completions g
compdef gha=_gha_completion

# ==============================================================================
# § END OF GIT CONFIGURATION
# ==============================================================================

# ------------------------------------------------------------------
# 5️⃣  Custom Functions – Interactive helpers
# ------------------------------------------------------------------
# 5a) fzf_rg – search text, pick a match, open in editor
function fzf_rg() {
  local line
  line=$(rg --color=always --line-number --no-heading "$@" |
         fzf --ansi \
             --delimiter : \
             --with-nth=1,2,3.. \
             --nth 3.. \
             --preview 'bat --style=numbers --color=always --highlight-line {2} {1}' \
             --preview-window 'up,60%,border-bottom,+{2}+3/3,~3')
  if [[ -n "$line" ]]; then
    local file=$(cut -d: -f1 <<< "$line")
    local line_num=$(cut -d: -f2 <<< "$line")
    ${EDITOR:-nvim} "$file" "+$line_num"
  fi
}

# 5b) fzf_cd – fuzzy change‑to‑directory
function fzf_cd() {
  local dir
  dir=$(fd --type d --hidden --exclude .git | fzf --preview 'eza --long --git {} | head -20')
  [[ -n "$dir" ]] && cd "$dir"
}

# 5c) fkill – interactive process killer (default SIGTERM)
function fkill() {
  local ps_cmd="ps -ef"
  [[ "$OSTYPE" == "darwin"* ]] && ps_cmd="ps aux"
  local pid
  pid=$($ps_cmd | sed 1d | fzf -m | awk '{print $2}')
  [[ -n "$pid" ]] && echo "$pid" | xargs kill -"${1:-15}"   # default to SIGTERM
}

# 5d) gco – fuzzy checkout of local or remote branch
function gco() {
  local branches branch
  branches=$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | \
             sed '/\/HEAD$/d' | sort -u)
  branch=$(echo "$branches" | fzf --height 30% --reverse)
  [[ -n "$branch" ]] && git checkout "$branch"
}

# 5e) gco_info – fuzzy checkout with last‑commit preview
function gco_info() {
  local branch
  branch=$(git branch -a | sed -e 's/^[* ] //g' | \
           fzf --preview 'git log -1 --oneline {}')
  [[ -n "$branch" ]] && git checkout "$branch"
}

# 5f) fzf_git – open a tracked file in your editor
function fzf_git() {
  local file
  file=$(git ls-files | fzf --preview 'bat --style=numbers --color=always {}')
  [[ -n "$file" ]] && ${EDITOR:-nvim} "$file"
}


# ------------------------------------------------------------------
# 6️⃣  Keybindings – zle widgets
# ------------------------------------------------------------------
# Register the functions as widgets before binding
zle -N fzf_cd
zle -N fzf_git
zle -N fco_info

# Choose keys that are unlikely to clash with normal shell editing
bindkey '^Xf' fzf_cd          # Ctrl‑X then f – fuzzy cd
bindkey '^Xg' fzf_git         # Ctrl‑X then g – fuzzy git file
bindkey '^Xc' gco_info        # Ctrl‑X then c – fuzzy checkout with preview


# ------------------------------------------------------------------
# 7️⃣  Environment Variables & PATH
# ------------------------------------------------------------------
export EDITOR="nvim"          # Default editor for functions
export PAGER="less"           # Use less for paging
export LESS="-R"              # Preserve ANSI colours in less
export GPG_TTY=$(tty)         # Needed for gpg agent

# Optional: start ssh‑agent if not already running
if ! pgrep -u "$USER" ssh-agent > /dev/null; then
#  eval "$(ssh-agent -c)"
  eval "$(ssh-agent -c)" > /dev/null 2>&1
  export SSH_AUTH_SOCK
fi

